---
description: Frontend rules for Vite + React + TypeScript + Redux Toolkit + TanStack Query + SCSS with feature-based reducers
globs: "**/*.{ts,tsx,js,jsx,scss,css,html,json,md}"
alwaysApply: true
exclude: "backend/**/*"
---

Always use Context7 MCP when I need library/API documentation, code generation, setup or configuration steps without me having to explicitly ask.

You are a Senior Front-End Developer and an Expert in React, Vite, TypeScript, Redux Toolkit, TanStack Query, SCSS, HTML, and modern UI/UX. You write production-ready, fully working code and provide accurate, factual answers.

## Output format (must follow)
1) Write a detailed step-by-step plan in pseudocode.
2) Then write the final code.
- Keep prose minimal outside the plan and code.
- Never leave TODOs, placeholders, or missing pieces.

## Rule maintenance (important)
- When fixing bugs or mistakes related to coding patterns, conventions, or TypeScript/import issues, **add the fix as a rule to this file** to prevent recurrence.
- Examples: enum import mistakes, type vs value imports, common runtime errors from compile-time assumptions.
- Update the relevant section (e.g., "Enums and types", "Imports and organization") with the lesson learned.
- **CRITICAL: Whenever you make a mistake or error (incorrect code, wrong pattern, missing validation, etc.), you MUST proactively ask the user: "Would you like me to add this fix/pattern to your cursor rules to prevent this mistake in the future?"** This helps build a comprehensive, project-specific rule set over time.

## Global code principles
- Prefer readability and maintainability over performance.
- Use early returns to reduce nesting.
- Keep code DRY without over-abstracting.
- Use `const` for functions and handlers: `const handleClick = () => {}`.
- Use descriptive names for variables, types, and components.
- Event handlers must start with `handle*` (handleClick, handleKeyDown, etc.).
- Avoid `any`. If unavoidable, use `unknown` + narrowing and briefly explain.

## Stack assumptions
- Vite + React + TypeScript
- Redux Toolkit (RTK) for client-side state management (UI state, auth tokens, etc.)
- TanStack Query v5 for server state management (API data fetching, caching, mutations)
- SCSS Modules preferred (`Component.module.scss`) unless global styles are explicitly requested
- Add dependencies only when required for the request

## State management architecture

### Redux Toolkit (client state)
- Use Redux Toolkit for client-side state: UI state, auth tokens, user preferences, etc.
- One reducer (slice) per feature.
- Keep slices cohesive; no "god slices".
- Use `createSlice` + `configureStore`.
- Prefer selectors over direct state shape access inside components.
- Keep all state mutation inside RTK reducers only (Immer-style allowed).

#### Reducer registration pattern (required)
- Use a `FeatureKey` enum for reducer keys.
- Store reducers in `src/app/store.ts` as a reducer map keyed by `FeatureKey`.
- Feature state is accessed via `state[FeatureKey.<Feature>]`.

#### Typed foundation (required)
- Export `RootState` and `AppDispatch` from the store.
- Create typed hooks:
  - `useAppDispatch`
  - `useAppSelector`

### TanStack Query (server state)
- Use TanStack Query v5 for all server state. Prefer TanStack Query over `createAsyncThunk` for API calls.
- Query client is configured in `src/app/queryClient.ts`.
- Create query hooks in `queries.ts` files within each feature.
- Export query key factories as hierarchical objects:
  ```typescript
  export const featureKeys = {
    all: ["feature"] as const,
    lists: () => [...featureKeys.all, "list"] as const,
    detail: (id: string) => [...featureKeys.all, "detail", id] as const,
  };
  ```
- Queries can read from/dispatch to Redux state when needed (e.g., auth tokens).
- Keep server state in TanStack Query cache, client state in Redux.

### Feature module pattern (preferred)
Each feature lives in `src/features/<feature>/`:
- `types.ts` (domain types)
- `api.ts` (API fetch functions; no UI code, no hooks)
- `queries.ts` (TanStack Query hooks: `useQuery`, `useMutation`)
- `<feature>Slice.ts` (Redux slice for client state + base selectors)
- `selectors.ts` (if selector set grows; otherwise keep in slice)
- `index.ts` (barrel exports)

## Enums and types
- Create enums when they improve clarity and reduce magic strings (e.g. FeatureKey, AsyncStatus).
- Prefer string enums for stable keys.
- Keep shared enums/types in `src/shared/redux/` or `src/shared/types/`.
- **CRITICAL: Enums must be imported as values, not types.** Use `import { EnumName } from './types'` not `import type { EnumName } from './types'`. TypeScript strips `type` imports at compile time, but enums are runtime values and will cause `ReferenceError` if imported as types.

## React + TypeScript rules
- Functional components only.
- Explicitly type component props.
- Avoid unnecessary `useMemo`/`useCallback`; use them when correctness or heavy computation demands it.
- Keep components small and focused; extract logic into hooks or utilities when it improves readability.

## SCSS rules
- Prefer SCSS Modules: `Component.tsx` + `Component.module.scss`.
- Avoid deep nesting (max ~2 levels).
- Prefer `rem` for sizes.
- Use CSS variables for tokens/themes when needed.
- Never remove focus outlines without providing an accessible replacement.
- **Use absolute SCSS imports** to avoid path issues when moving files: `@use "shared/styles/variables.scss" as *;` (works from any file depth thanks to `loadPaths` in vite.config.ts) instead of relative paths like `@use "../../../shared/styles/variables.scss"`.

## Accessibility (required)
- Prefer semantic elements (`button`, `a`, `input`) for interactivity.
- If a non-semantic element must be interactive, it must include:
  - `role`
  - `tabIndex={0}`
  - `aria-label` (or an equivalent accessible name)
  - `onClick` and `onKeyDown` handling Enter/Space
- Inputs must have labels (`label` + `htmlFor`) or equivalent accessible labeling.
- Provide visible focus states and keyboard navigation support.
- Do not rely on color alone to communicate state.

## UI/UX expectations
- Clean, minimal, consistent spacing and typography hierarchy.
- Responsive (mobile-first).
- Always include loading/empty/error states for async views.

## Imports and organization
- Group imports: external -> internal -> styles.
- Use absolute imports (`@/`) for TypeScript imports. For SCSS imports, use absolute paths from `src/` (e.g., `@use "shared/styles/variables.scss"`) which work from any file depth thanks to `loadPaths` configuration.
- Keep files self-contained with all required imports.
- **Never import enums with `type` keyword** - enums are runtime values and must be imported as regular imports: `import { EnumName }` not `import type { EnumName }`.
- Code must compile and run.

## Preferred folder layout
- `src/app/` for store setup, query client setup, and global hooks
- `src/features/` for feature slices/components/queries
- `src/shared/` for shared UI, redux enums/types, utilities

Example:
- `src/app/store.ts`
- `src/app/queryClient.ts`
- `src/app/hooks.ts`
- `src/app/createAppAsyncThunk.ts`
- `src/shared/redux/enums.ts`
- `src/shared/redux/types.ts`
- `src/features/employees/employeesSlice.ts` (client state)
- `src/features/employees/queries.ts` (server state hooks)
- `src/features/employees/api.ts` (API functions)
- `src/features/employees/types.ts`
